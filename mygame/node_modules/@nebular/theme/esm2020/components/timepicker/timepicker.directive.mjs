import { Attribute, Directive, forwardRef, Inject, Input, isDevMode, } from '@angular/core';
import { distinctUntilChanged, filter, map, pairwise, startWith, takeUntil } from 'rxjs/operators';
import { fromEvent, merge, Subject } from 'rxjs';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NbAdjustment, NbPosition, } from '../cdk/overlay/overlay-position';
import { NbTrigger } from '../cdk/overlay/overlay-trigger';
import { NB_DOCUMENT } from '../../theme.options';
import * as i0 from "@angular/core";
import * as i1 from "../cdk/overlay/overlay-position";
import * as i2 from "../cdk/overlay/overlay-trigger";
import * as i3 from "../cdk/overlay/overlay-service";
import * as i4 from "../calendar-kit/services/calendar-time-model.service";
import * as i5 from "../calendar-kit/services/date.service";
/**
 * The `NbTimePickerDirective` is form control that gives you ability to select a time. The timepicker
 * is shown when input receives a `focus` event.
 * ```html
 * <input [nbTimepicker]="timepicker">
 * <nb-timepicker #timepicker></nb-timepicker>
 * ```
 *
 * @stacked-example(Showcase, timepicker/timepicker-showcase.component)
 *
 * ### Installation
 *
 * Import `NbTimepickerModule.forRoot()` to your root module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTimepickerModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * And `NbTimepickerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTimepickerModule,
 *   ],
 * })
 * export class PageModule { }
 *
 * ```
 * <div id="native-parse-issue" class="note note-warning">
 * <div class="note-title">Note</div>
 * <div class="note-body">
 * Timepicker uses native Date object by default, which doesn't support parsing by custom format.
 * According to the ECMAScript specification, the only supported format is a format described by ISO 8061 standard.
 * This standard requires date part to be included in the date string,
 * meaning you have to type a date+time in the input.
 * We highly recommend you to use NbDateFnsDateModule or NbMomentDateModule to be able to support time only strings in
 * the timepicker inputs. These modules use date-fns and moment date libraries, which provide capabilities
 * to parse time only strings.
 * See "Formatting Issue" at
 * <a href="https://akveo.github.io/nebular/docs/components/datepicker/overview#formatting-issue">Date picker docs</a>
 * for installation instructions.
 * </div>
 * </div>
 * <hr>
 *
 * ### Usage
 *
 * To show seconds column along with hours and minutes use `withSeconds` input
 *
 * ```html
 * <input [nbTimepicker]="timepicker">
 * <nb-timepicker #timepicker withSeconds></nb-timepicker>
 * ```
 * @stacked-example(Time picker with seconds, timepicker/timepicker-with-seconds.component)
 *
 * To force timepicker work in 12 hours format, use `twelveHoursFormat` input.
 * By default, timepicker choose 12 or 24 formats based on application locale standards
 *
 * ```html
 * <input [nbTimepicker]="timepicker" twelveHoursFormat>
 * <nb-timepicker #timepicker></nb-timepicker>
 * ```
 *
 * @stacked-example(Twelve hours format showcase, timepicker/timepicker-twelve-hours-format.component)
 *
 * A single column picker with options value as time and minute, so users wonâ€™t be able to pick
 * hours and minutes individually.
 * You can control options minutes offset via `step` input, e.g.: 11:00, 11:20, 11:40...'
 *
 * @stacked-example(Single column, timepicker/timepicker-single-column.component)
 *
 * Timepicker support forms and reactive forms API so you can provide value using `formControl` and `ngModel` directives
 * @stacked-example(Form control, timepicker/timepicker-form-control.component)
 *
 * <input [nbTimepicker]="timepicker" twelveHoursFormat>
 * <nb-timepicker #timepicke [formControl]="formControl"></nb-timepicker>
 *
 * @stacked-example(NgModel, timepicker/timepicker-ng-model.component)
 *
 * <input [nbTimepicker]="timepicker" twelveHoursFormat>
 * <nb-timepicker #timepicke [ngModel]="date"></nb-timepicker>
 *
 * You can provide localized versions of the timepicker text via the `localization` property of the config
 * object passed to the `forRoot` or `forChild` methods of the `NbTimepickerModule`:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTimepickerModule.forRoot({
 *       localization: {
 *         hoursText: 'Hr',
 *         minutesText: 'Min',
 *         secondsText: 'Sec',
 *         ampmText: 'Am/Pm',
 *       }
 *     }),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * @styles
 *
 * timepicker-cell-text-color:
 * timepicker-cell-hover-background-color:
 * timepicker-cell-hover-text-color:
 * timepicker-cell-focus-background-color:
 * timepicker-cell-focus-text-color:
 * timepicker-cell-active-background-color:
 * timepicker-cell-active-text-color:
 * timepicker-cell-text-font-size:
 * timepicker-cell-text-font-family:
 * timepicker-cell-text-line-height:
 * timepicker-cell-text-font-weight:
 * timepicker-cell-height:
 * timepicker-header-cell-text-color:
 * timepicker-header-cell-text-font-size:
 * timepicker-header-cell-text-font-family:
 * timepicker-header-cell-height:
 * timepicker-header-cell-text-line-height:
 * timepicker-header-cell-text-font-weight:
 * timepicker-border-color:
 * timepicker-border-style:
 * timepicker-border-width:
 * timepicker-scrollbar-color:
 * timepicker-scrollbar-background-color:
 * timepicker-scrollbar-width:
 * timepicker-single-column-width:
 * timepicker-multiple-column-width:
 * timepicker-title-height:
 * timepicker-title-padding:
 * timepicker-container-width:
 * timepicker-container-height:
 * */
export class NbTimePickerDirective {
    /**
     * Provides timepicker component.
     * */
    get timepicker() {
        return this._timePickerComponent;
    }
    set timepicker(timePicker) {
        this._timePickerComponent = timePicker;
        this.pickerInputsChangedSubscription?.unsubscribe();
        this.pickerInputsChangedSubscription = this._timePickerComponent.timepickerFormatChange$
            .pipe(map(() => this._timePickerComponent.computedTimeFormat), startWith(this._timePickerComponent.computedTimeFormat), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$))
            .subscribe(([prevFormat, nextFormat]) => {
            if (this.inputValue) {
                const date = this.dateService.parse(this.inputValue, prevFormat);
                this.writeValue(date);
            }
        });
    }
    /**
     * Returns html input element.
     * @docs-private
     * */
    get input() {
        return this.hostRef.nativeElement;
    }
    /**
     * Determines is timepicker overlay opened.
     * @docs-private
     * */
    get isOpen() {
        return this.overlayRef && this.overlayRef.hasAttached();
    }
    /**
     * Determines is timepicker overlay closed.
     * @docs-private
     * */
    get isClosed() {
        return !this.isOpen;
    }
    constructor(document, positionBuilder, hostRef, triggerStrategyBuilder, overlay, cd, calendarTimeModelService, dateService, renderer, placeholder) {
        this.document = document;
        this.positionBuilder = positionBuilder;
        this.hostRef = hostRef;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.overlay = overlay;
        this.cd = cd;
        this.calendarTimeModelService = calendarTimeModelService;
        this.dateService = dateService;
        this.renderer = renderer;
        this.placeholder = placeholder;
        /**
         * Time picker overlay offset.
         * */
        this.overlayOffset = 8;
        this.destroy$ = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    /**
     * Returns host input value.
     * @docs-private
     * */
    get inputValue() {
        return this.input.value;
    }
    set inputValue(value) {
        this.input.value = value;
    }
    ngAfterViewInit() {
        this.subscribeOnInputChange();
        if (!this.placeholder) {
            this.renderer.setProperty(this.input, 'placeholder', this.timepicker.computedTimeFormat);
        }
        this.triggerStrategy = this.createTriggerStrategy();
        this.subscribeOnTriggers();
        this.subscribeToBlur();
    }
    show() {
        if (this.isClosed) {
            this.attachToOverlay();
        }
    }
    hide() {
        if (this.isOpen) {
            this.overlayRef.detach();
            this.cd.markForCheck();
        }
    }
    /**
     * Attaches picker to the timepicker portal.
     * @docs-private
     * */
    attachToOverlay() {
        if (!this.overlayRef) {
            this.setupTimepicker();
            this.initOverlay();
        }
        this.overlayRef.attach(this.timepicker.portal);
    }
    setupTimepicker() {
        if (this.dateService.getId() === 'native' && isDevMode()) {
            console.warn('Date.parse does not support parsing time with custom format.' +
                ' See details here https://akveo.github.io/nebular/docs/components/datepicker/overview#native-parse-issue');
        }
        this.timepicker.setHost(this.hostRef);
        if (this.inputValue) {
            const val = this.dateService.getId() === 'native' ? this.parseNativeDateString(this.inputValue) : this.inputValue;
            this.timepicker.date = this.dateService.parse(val, this.timepicker.computedTimeFormat);
        }
        else {
            this.timepicker.date = this.calendarTimeModelService.getResetTime();
        }
    }
    initOverlay() {
        this.positionStrategy = this.createPositionStrategy();
        this.subscribeOnApplyClick();
        this.createOverlay();
    }
    subscribeOnApplyClick() {
        this.timepicker.onSelectTime.pipe(takeUntil(this.destroy$)).subscribe((value) => {
            const time = this.dateService.format(value.time, this.timepicker.computedTimeFormat).toUpperCase();
            this.inputValue = time;
            this.timepicker.date = value.time;
            this.onChange(value.time);
            if (value.save) {
                this.lastInputValue = time;
                this.hide();
            }
        });
    }
    createOverlay() {
        const scrollStrategy = this.createScrollStrategy();
        this.overlayRef = this.overlay.create({ positionStrategy: this.positionStrategy, scrollStrategy });
    }
    subscribeOnTriggers() {
        this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
        this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => {
            this.inputValue = this.lastInputValue || '';
            this.hide();
        });
    }
    createTriggerStrategy() {
        return this.triggerStrategyBuilder
            .trigger(NbTrigger.FOCUS)
            .host(this.hostRef.nativeElement)
            .container(() => this.getContainer())
            .build();
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this.hostRef)
            .position(NbPosition.BOTTOM)
            .offset(this.overlayOffset)
            .adjustment(NbAdjustment.COUNTERCLOCKWISE);
    }
    getContainer() {
        return (this.overlayRef &&
            this.isOpen &&
            {
                location: {
                    nativeElement: this.overlayRef.overlayElement,
                },
            });
    }
    createScrollStrategy() {
        return this.overlay.scrollStrategies.block();
    }
    subscribeOnInputChange() {
        fromEvent(this.input, 'input')
            .pipe(map(() => this.inputValue), takeUntil(this.destroy$))
            .subscribe((value) => this.handleInputChange(value));
    }
    subscribeToBlur() {
        merge(this.timepicker.blur, fromEvent(this.input, 'blur').pipe(filter(() => !this.isOpen && this.document.activeElement !== this.input)))
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.onTouched());
    }
    /**
     * Parses input value and write if it isn't null.
     * @docs-private
     * */
    handleInputChange(value) {
        if (this.dateService.getId() === 'native') {
            /**
             * Native date service dont parse only time string value,
             * and we adding year mouth and day to convert string to valid date format
             **/
            value = this.parseNativeDateString(value);
        }
        const isValidDate = this.dateService.isValidDateString(value, this.timepicker.computedTimeFormat);
        if (isValidDate) {
            this.lastInputValue = value;
            const date = this.dateService.parse(value, this.timepicker.computedTimeFormat);
            this.onChange(date);
            this.timepicker.date = date;
        }
    }
    updateValue(value) {
        if (value) {
            this.timepicker.date = value;
            const timeString = this.dateService.format(value, this.timepicker.computedTimeFormat).toUpperCase();
            this.inputValue = timeString;
            this.lastInputValue = timeString;
        }
    }
    writeValue(value) {
        this.updateValue(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.input.disabled = isDisabled;
    }
    parseNativeDateString(value) {
        const date = this.dateService.today();
        const year = this.dateService.getYear(date);
        const month = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getMonth(date));
        const day = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getDate(date));
        return `${year}-${month}-${day} ${value}`;
    }
}
NbTimePickerDirective.Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbTimePickerDirective, deps: [{ token: NB_DOCUMENT }, { token: i1.NbPositionBuilderService }, { token: i0.ElementRef }, { token: i2.NbTriggerStrategyBuilderService }, { token: i3.NbOverlayService }, { token: i0.ChangeDetectorRef }, { token: i4.NbCalendarTimeModelService }, { token: i5.NbDateService }, { token: i0.Renderer2 }, { token: 'placeholder', attribute: true }], target: i0.ÉµÉµFactoryTarget.Directive });
NbTimePickerDirective.Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: NbTimePickerDirective, selector: "input[nbTimepicker]", inputs: { timepicker: ["nbTimepicker", "timepicker"], overlayOffset: "overlayOffset" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => NbTimePickerDirective),
            multi: true,
        },
    ], ngImport: i0 });
i0.ÉµÉµngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbTimePickerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[nbTimepicker]',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NbTimePickerDirective),
                            multi: true,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [NB_DOCUMENT]
                }] }, { type: i1.NbPositionBuilderService }, { type: i0.ElementRef }, { type: i2.NbTriggerStrategyBuilderService }, { type: i3.NbOverlayService }, { type: i0.ChangeDetectorRef }, { type: i4.NbCalendarTimeModelService }, { type: i5.NbDateService }, { type: i0.Renderer2 }, { type: undefined, decorators: [{
                    type: Attribute,
                    args: ['placeholder']
                }] }]; }, propDecorators: { timepicker: [{
                type: Input,
                args: ['nbTimepicker']
            }], overlayOffset: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXBpY2tlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL3RoZW1lL2NvbXBvbmVudHMvdGltZXBpY2tlci90aW1lcGlja2VyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsU0FBUyxFQUdULFNBQVMsRUFFVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxTQUFTLEdBRVYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRyxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQy9ELE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUd6RSxPQUFPLEVBRUwsWUFBWSxFQUNaLFVBQVUsR0FFWCxNQUFNLGlDQUFpQyxDQUFDO0FBRXpDLE9BQU8sRUFBRSxTQUFTLEVBQXNELE1BQU0sZ0NBQWdDLENBQUM7QUFJL0csT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7Ozs7O0FBRWxEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0EwSUs7QUFXTCxNQUFNLE9BQU8scUJBQXFCO0lBQ2hDOztTQUVLO0lBQ0wsSUFDSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUM7SUFDbkMsQ0FBQztJQUVELElBQUksVUFBVSxDQUFDLFVBQW9DO1FBQ2pELElBQUksQ0FB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QUFpQjs0QkFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsc0JBQXNCLENBQUM7NEJBQ3BELEtBQUssRUFBRSxJQUFJO3lCQUNaO3FCQUNGO2lCQUNGOzswQkFvRkksTUFBTTsyQkFBQyxXQUFXOzswQkFTbEIsU0FBUzsyQkFBQyxhQUFhOzRDQXZGdEIsVUFBVTtzQkFEYixLQUFLO3VCQUFDLGNBQWM7Z0JBOEJaLGFBQWE7c0JBQXJCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBBdHRyaWJ1dGUsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnRSZWYsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgZm9yd2FyZFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgaXNEZXZNb2RlLFxuICBSZW5kZXJlcjIsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgbWFwLCBwYWlyd2lzZSwgc3RhcnRXaXRoLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE5iVGltZVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vdGltZXBpY2tlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmJPdmVybGF5UmVmLCBOYlNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvbWFwcGluZyc7XG5pbXBvcnQge1xuICBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LFxuICBOYkFkanVzdG1lbnQsXG4gIE5iUG9zaXRpb24sXG4gIE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSxcbn0gZnJvbSAnLi4vY2RrL292ZXJsYXkvb3ZlcmxheS1wb3NpdGlvbic7XG5pbXBvcnQgeyBOYk92ZXJsYXlTZXJ2aWNlIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvb3ZlcmxheS1zZXJ2aWNlJztcbmltcG9ydCB7IE5iVHJpZ2dlciwgTmJUcmlnZ2VyU3RyYXRlZ3ksIE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9vdmVybGF5LXRyaWdnZXInO1xuaW1wb3J0IHsgTmJTZWxlY3RlZFRpbWVQYXlsb2FkIH0gZnJvbSAnLi9tb2RlbCc7XG5pbXBvcnQgeyBOYkRhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vY2FsZW5kYXIta2l0L3NlcnZpY2VzL2RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBOYkNhbGVuZGFyVGltZU1vZGVsU2VydmljZSB9IGZyb20gJy4uL2NhbGVuZGFyLWtpdC9zZXJ2aWNlcy9jYWxlbmRhci10aW1lLW1vZGVsLnNlcnZpY2UnO1xuaW1wb3J0IHsgTkJfRE9DVU1FTlQgfSBmcm9tICcuLi8uLi90aGVtZS5vcHRpb25zJztcblxuLyoqXG4gKiBUaGUgYE5iVGltZVBpY2tlckRpcmVjdGl2ZWAgaXMgZm9ybSBjb250cm9sIHRoYXQgZ2l2ZXMgeW91IGFiaWxpdHkgdG8gc2VsZWN0IGEgdGltZS4gVGhlIHRpbWVwaWNrZXJcbiAqIGlzIHNob3duIHdoZW4gaW5wdXQgcmVjZWl2ZXMgYSBgZm9jdXNgIGV2ZW50LlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYlRpbWVwaWNrZXJdPVwidGltZXBpY2tlclwiPlxuICogPG5iLXRpbWVwaWNrZXIgI3RpbWVwaWNrZXI+PC9uYi10aW1lcGlja2VyPlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgdGltZXBpY2tlci90aW1lcGlja2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRpbWVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIHJvb3QgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRpbWVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqIEFuZCBgTmJUaW1lcGlja2VyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRpbWVwaWNrZXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKlxuICogYGBgXG4gKiA8ZGl2IGlkPVwibmF0aXZlLXBhcnNlLWlzc3VlXCIgY2xhc3M9XCJub3RlIG5vdGUtd2FybmluZ1wiPlxuICogPGRpdiBjbGFzcz1cIm5vdGUtdGl0bGVcIj5Ob3RlPC9kaXY+XG4gKiA8ZGl2IGNsYXNzPVwibm90ZS1ib2R5XCI+XG4gKiBUaW1lcGlja2VyIHVzZXMgbmF0aXZlIERhdGUgb2JqZWN0IGJ5IGRlZmF1bHQsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwYXJzaW5nIGJ5IGN1c3RvbSBmb3JtYXQuXG4gKiBBY2NvcmRpbmcgdG8gdGhlIEVDTUFTY3JpcHQgc3BlY2lmaWNhdGlvbiwgdGhlIG9ubHkgc3VwcG9ydGVkIGZvcm1hdCBpcyBhIGZvcm1hdCBkZXNjcmliZWQgYnkgSVNPIDgwNjEgc3RhbmRhcmQuXG4gKiBUaGlzIHN0YW5kYXJkIHJlcXVpcmVzIGRhdGUgcGFydCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBzdHJpbmcsXG4gKiBtZWFuaW5nIHlvdSBoYXZlIHRvIHR5cGUgYSBkYXRlK3RpbWUgaW4gdGhlIGlucHV0LlxuICogV2UgaGlnaGx5IHJlY29tbWVuZCB5b3UgdG8gdXNlIE5iRGF0ZUZuc0RhdGVNb2R1bGUgb3IgTmJNb21lbnREYXRlTW9kdWxlIHRvIGJlIGFibGUgdG8gc3VwcG9ydCB0aW1lIG9ubHkgc3RyaW5ncyBpblxuICogdGhlIHRpbWVwaWNrZXIgaW5wdXRzLiBUaGVzZSBtb2R1bGVzIHVzZSBkYXRlLWZucyBhbmQgbW9tZW50IGRhdGUgbGlicmFyaWVzLCB3aGljaCBwcm92aWRlIGNhcGFiaWxpdGllc1xuICogdG8gcGFyc2UgdGltZSBvbmx5IHN0cmluZ3MuXG4gKiBTZWUgXCJGb3JtYXR0aW5nIElzc3VlXCIgYXRcbiAqIDxhIGhyZWY9XCJodHRwczovL2FrdmVvLmdpdGh1Yi5pby9uZWJ1bGFyL2RvY3MvY29tcG9uZW50cy9kYXRlcGlja2VyL292ZXJ2aWV3I2Zvcm1hdHRpbmctaXNzdWVcIj5EYXRlIHBpY2tlciBkb2NzPC9hPlxuICogZm9yIGluc3RhbGxhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKiA8L2Rpdj5cbiAqIDwvZGl2PlxuICogPGhyPlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFRvIHNob3cgc2Vjb25kcyBjb2x1bW4gYWxvbmcgd2l0aCBob3VycyBhbmQgbWludXRlcyB1c2UgYHdpdGhTZWNvbmRzYCBpbnB1dFxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJUaW1lcGlja2VyXT1cInRpbWVwaWNrZXJcIj5cbiAqIDxuYi10aW1lcGlja2VyICN0aW1lcGlja2VyIHdpdGhTZWNvbmRzPjwvbmItdGltZXBpY2tlcj5cbiAqIGBgYFxuICogQHN0YWNrZWQtZXhhbXBsZShUaW1lIHBpY2tlciB3aXRoIHNlY29uZHMsIHRpbWVwaWNrZXIvdGltZXBpY2tlci13aXRoLXNlY29uZHMuY29tcG9uZW50KVxuICpcbiAqIFRvIGZvcmNlIHRpbWVwaWNrZXIgd29yayBpbiAxMiBob3VycyBmb3JtYXQsIHVzZSBgdHdlbHZlSG91cnNGb3JtYXRgIGlucHV0LlxuICogQnkgZGVmYXVsdCwgdGltZXBpY2tlciBjaG9vc2UgMTIgb3IgMjQgZm9ybWF0cyBiYXNlZCBvbiBhcHBsaWNhdGlvbiBsb2NhbGUgc3RhbmRhcmRzXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYlRpbWVwaWNrZXJdPVwidGltZXBpY2tlclwiIHR3ZWx2ZUhvdXJzRm9ybWF0PlxuICogPG5iLXRpbWVwaWNrZXIgI3RpbWVwaWNrZXI+PC9uYi10aW1lcGlja2VyPlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShUd2VsdmUgaG91cnMgZm9ybWF0IHNob3djYXNlLCB0aW1lcGlja2VyL3RpbWVwaWNrZXItdHdlbHZlLWhvdXJzLWZvcm1hdC5jb21wb25lbnQpXG4gKlxuICogQSBzaW5nbGUgY29sdW1uIHBpY2tlciB3aXRoIG9wdGlvbnMgdmFsdWUgYXMgdGltZSBhbmQgbWludXRlLCBzbyB1c2VycyB3b27igJl0IGJlIGFibGUgdG8gcGlja1xuICogaG91cnMgYW5kIG1pbnV0ZXMgaW5kaXZpZHVhbGx5LlxuICogWW91IGNhbiBjb250cm9sIG9wdGlvbnMgbWludXRlcyBvZmZzZXQgdmlhIGBzdGVwYCBpbnB1dCwgZS5nLjogMTE6MDAsIDExOjIwLCAxMTo0MC4uLidcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpbmdsZSBjb2x1bW4sIHRpbWVwaWNrZXIvdGltZXBpY2tlci1zaW5nbGUtY29sdW1uLmNvbXBvbmVudClcbiAqXG4gKiBUaW1lcGlja2VyIHN1cHBvcnQgZm9ybXMgYW5kIHJlYWN0aXZlIGZvcm1zIEFQSSBzbyB5b3UgY2FuIHByb3ZpZGUgdmFsdWUgdXNpbmcgYGZvcm1Db250cm9sYCBhbmQgYG5nTW9kZWxgIGRpcmVjdGl2ZXNcbiAqIEBzdGFja2VkLWV4YW1wbGUoRm9ybSBjb250cm9sLCB0aW1lcGlja2VyL3RpbWVwaWNrZXItZm9ybS1jb250cm9sLmNvbXBvbmVudClcbiAqXG4gKiA8aW5wdXQgW25iVGltZXBpY2tlcl09XCJ0aW1lcGlja2VyXCIgdHdlbHZlSG91cnNGb3JtYXQ+XG4gKiA8bmItdGltZXBpY2tlciAjdGltZXBpY2tlIFtmb3JtQ29udHJvbF09XCJmb3JtQ29udHJvbFwiPjwvbmItdGltZXBpY2tlcj5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKE5nTW9kZWwsIHRpbWVwaWNrZXIvdGltZXBpY2tlci1uZy1tb2RlbC5jb21wb25lbnQpXG4gKlxuICogPGlucHV0IFtuYlRpbWVwaWNrZXJdPVwidGltZXBpY2tlclwiIHR3ZWx2ZUhvdXJzRm9ybWF0PlxuICogPG5iLXRpbWVwaWNrZXIgI3RpbWVwaWNrZSBbbmdNb2RlbF09XCJkYXRlXCI+PC9uYi10aW1lcGlja2VyPlxuICpcbiAqIFlvdSBjYW4gcHJvdmlkZSBsb2NhbGl6ZWQgdmVyc2lvbnMgb2YgdGhlIHRpbWVwaWNrZXIgdGV4dCB2aWEgdGhlIGBsb2NhbGl6YXRpb25gIHByb3BlcnR5IG9mIHRoZSBjb25maWdcbiAqIG9iamVjdCBwYXNzZWQgdG8gdGhlIGBmb3JSb290YCBvciBgZm9yQ2hpbGRgIG1ldGhvZHMgb2YgdGhlIGBOYlRpbWVwaWNrZXJNb2R1bGVgOlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRpbWVwaWNrZXJNb2R1bGUuZm9yUm9vdCh7XG4gKiAgICAgICBsb2NhbGl6YXRpb246IHtcbiAqICAgICAgICAgaG91cnNUZXh0OiAnSHInLFxuICogICAgICAgICBtaW51dGVzVGV4dDogJ01pbicsXG4gKiAgICAgICAgIHNlY29uZHNUZXh0OiAnU2VjJyxcbiAqICAgICAgICAgYW1wbVRleHQ6ICdBbS9QbScsXG4gKiAgICAgICB9XG4gKiAgICAgfSksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0aW1lcGlja2VyLWNlbGwtdGV4dC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItY2VsbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLWhvdmVyLXRleHQtY29sb3I6XG4gKiB0aW1lcGlja2VyLWNlbGwtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItY2VsbC1mb2N1cy10ZXh0LWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLXRleHQtZm9udC1zaXplOlxuICogdGltZXBpY2tlci1jZWxsLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0aW1lcGlja2VyLWNlbGwtdGV4dC1saW5lLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItY2VsbC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdGltZXBpY2tlci1jZWxsLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1mb250LXNpemU6XG4gKiB0aW1lcGlja2VyLWhlYWRlci1jZWxsLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0aW1lcGlja2VyLWhlYWRlci1jZWxsLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1saW5lLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1mb250LXdlaWdodDpcbiAqIHRpbWVwaWNrZXItYm9yZGVyLWNvbG9yOlxuICogdGltZXBpY2tlci1ib3JkZXItc3R5bGU6XG4gKiB0aW1lcGlja2VyLWJvcmRlci13aWR0aDpcbiAqIHRpbWVwaWNrZXItc2Nyb2xsYmFyLWNvbG9yOlxuICogdGltZXBpY2tlci1zY3JvbGxiYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItc2Nyb2xsYmFyLXdpZHRoOlxuICogdGltZXBpY2tlci1zaW5nbGUtY29sdW1uLXdpZHRoOlxuICogdGltZXBpY2tlci1tdWx0aXBsZS1jb2x1bW4td2lkdGg6XG4gKiB0aW1lcGlja2VyLXRpdGxlLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItdGl0bGUtcGFkZGluZzpcbiAqIHRpbWVwaWNrZXItY29udGFpbmVyLXdpZHRoOlxuICogdGltZXBpY2tlci1jb250YWluZXItaGVpZ2h0OlxuICogKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W25iVGltZXBpY2tlcl0nLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5iVGltZVBpY2tlckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBOYlRpbWVQaWNrZXJEaXJlY3RpdmU8RD4gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gIC8qKlxuICAgKiBQcm92aWRlcyB0aW1lcGlja2VyIGNvbXBvbmVudC5cbiAgICogKi9cbiAgQElucHV0KCduYlRpbWVwaWNrZXInKVxuICBnZXQgdGltZXBpY2tlcigpOiBOYlRpbWVQaWNrZXJDb21wb25lbnQ8RD4ge1xuICAgIHJldHVybiB0aGlzLl90aW1lUGlja2VyQ29tcG9uZW50O1xuICB9XG5cbiAgc2V0IHRpbWVwaWNrZXIodGltZVBpY2tlcjogTmJUaW1lUGlja2VyQ29tcG9uZW50PEQ+KSB7XG4gICAgdGhpcy5fdGltZVBpY2tlckNvbXBvbmVudCA9IHRpbWVQaWNrZXI7XG5cbiAgICB0aGlzLnBpY2tlcklucHV0c0NoYW5nZWRTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5waWNrZXJJbnB1dHNDaGFuZ2VkU3Vic2NyaXB0aW9uID0gdGhpcy5fdGltZVBpY2tlckNvbXBvbmVudC50aW1lcGlja2VyRm9ybWF0Q2hhbmdlJFxuICAgICAgLnBpcGUoXG4gICAgICAgIG1hcCgoKSA9PiB0aGlzLl90aW1lUGlja2VyQ29tcG9uZW50LmNvbXB1dGVkVGltZUZvcm1hdCksXG4gICAgICAgIHN0YXJ0V2l0aCh0aGlzLl90aW1lUGlja2VyQ29tcG9uZW50LmNvbXB1dGVkVGltZUZvcm1hdCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICAgIHBhaXJ3aXNlKCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKFtwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0XSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pbnB1dFZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UucGFyc2UodGhpcy5pbnB1dFZhbHVlLCBwcmV2Rm9ybWF0KTtcbiAgICAgICAgICB0aGlzLndyaXRlVmFsdWUoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIHByb3RlY3RlZCBfdGltZVBpY2tlckNvbXBvbmVudDogTmJUaW1lUGlja2VyQ29tcG9uZW50PEQ+O1xuICBwcm90ZWN0ZWQgcGlja2VySW5wdXRzQ2hhbmdlZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaW1lIHBpY2tlciBvdmVybGF5IG9mZnNldC5cbiAgICogKi9cbiAgQElucHV0KCkgb3ZlcmxheU9mZnNldCA9IDg7XG5cbiAgLyoqXG4gICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBsYXRlc3Qgc2VsZWN0ZWQgZGF0ZS5cbiAgICogVXBkYXRlZCB3aGVuIHZhbHVlIGlzIHVwZGF0ZWQgcHJvZ3JhbW1hdGljYWxseSAod3JpdGVWYWx1ZSksIHZpYSB0aW1lcGlja2VyIChzdWJzY3JpYmVPbkFwcGx5Q2xpY2spXG4gICAqIG9yIHZpYSBpbnB1dCBmaWVsZCAoaGFuZGxlSW5wdXRDaGFuZ2UpXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBsYXN0SW5wdXRWYWx1ZTogc3RyaW5nO1xuICAvKipcbiAgICogUG9zaXRpb25pbmcgc3RyYXRlZ3kgdXNlZCBieSBvdmVybGF5LlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqICovXG4gIHByb3RlY3RlZCBwb3NpdGlvblN0cmF0ZWd5OiBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xuICBwcm90ZWN0ZWQgb3ZlcmxheVJlZjogTmJPdmVybGF5UmVmO1xuICBwcm90ZWN0ZWQgZGVzdHJveSQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwcm90ZWN0ZWQgb25DaGFuZ2U6ICh2YWx1ZTogRCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICBwcm90ZWN0ZWQgb25Ub3VjaGVkID0gKCkgPT4ge307XG4gIC8qKlxuICAgKiBUcmlnZ2VyIHN0cmF0ZWd5IHVzZWQgYnkgb3ZlcmxheS5cbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiAqL1xuICBwcm90ZWN0ZWQgdHJpZ2dlclN0cmF0ZWd5OiBOYlRyaWdnZXJTdHJhdGVneTtcblxuICAvKipcbiAgICogUmV0dXJucyBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogKi9cbiAgZ2V0IGlucHV0KCk6IEhUTUxJbnB1dEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlzIHRpbWVwaWNrZXIgb3ZlcmxheSBvcGVuZWQuXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogKi9cbiAgZ2V0IGlzT3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmICYmIHRoaXMub3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaXMgdGltZXBpY2tlciBvdmVybGF5IGNsb3NlZC5cbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiAqL1xuICBnZXQgaXNDbG9zZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmlzT3BlbjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoTkJfRE9DVU1FTlQpIHByb3RlY3RlZCBkb2N1bWVudCxcbiAgICBwcm90ZWN0ZWQgcG9zaXRpb25CdWlsZGVyOiBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGhvc3RSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHJvdGVjdGVkIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXI6IE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIG92ZXJsYXk6IE5iT3ZlcmxheVNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcm90ZWN0ZWQgY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlOiBOYkNhbGVuZGFyVGltZU1vZGVsU2VydmljZTxEPixcbiAgICBwcm90ZWN0ZWQgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD4sXG4gICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgQEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSBwcm90ZWN0ZWQgcGxhY2Vob2xkZXI6IHN0cmluZyxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhvc3QgaW5wdXQgdmFsdWUuXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogKi9cbiAgZ2V0IGlucHV0VmFsdWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTtcbiAgfVxuXG4gIHNldCBpbnB1dFZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmlucHV0LnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVPbklucHV0Q2hhbmdlKCk7XG5cbiAgICBpZiAoIXRoaXMucGxhY2Vob2xkZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dCwgJ3BsYWNlaG9sZGVyJywgdGhpcy50aW1lcGlja2VyLmNvbXB1dGVkVGltZUZvcm1hdCk7XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVUcmlnZ2VyU3RyYXRlZ3koKTtcbiAgICB0aGlzLnN1YnNjcmliZU9uVHJpZ2dlcnMoKTtcbiAgICB0aGlzLnN1YnNjcmliZVRvQmx1cigpO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhpcy5hdHRhY2hUb092ZXJsYXkoKTtcbiAgICB9XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgcGlja2VyIHRvIHRoZSB0aW1lcGlja2VyIHBvcnRhbC5cbiAgICogQGRvY3MtcHJpdmF0ZVxuICAgKiAqL1xuICBwcm90ZWN0ZWQgYXR0YWNoVG9PdmVybGF5KCkge1xuICAgIGlmICghdGhpcy5vdmVybGF5UmVmKSB7XG4gICAgICB0aGlzLnNldHVwVGltZXBpY2tlcigpO1xuICAgICAgdGhpcy5pbml0T3ZlcmxheSgpO1xuICAgIH1cbiAgICB0aGlzLm92ZXJsYXlSZWYuYXR0YWNoKHRoaXMudGltZXBpY2tlci5wb3J0YWwpO1xuICB9XG5cbiAgc2V0dXBUaW1lcGlja2VyKCkge1xuICAgIGlmICh0aGlzLmRhdGVTZXJ2aWNlLmdldElkKCkgPT09ICduYXRpdmUnICYmIGlzRGV2TW9kZSgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdEYXRlLnBhcnNlIGRvZXMgbm90IHN1cHBvcnQgcGFyc2luZyB0aW1lIHdpdGggY3VzdG9tIGZvcm1hdC4nICtcbiAgICAgICAgICAnIFNlZSBkZXRhaWxzIGhlcmUgaHR0cHM6Ly9ha3Zlby5naXRodWIuaW8vbmVidWxhci9kb2NzL2NvbXBvbmVudHMvZGF0ZXBpY2tlci9vdmVydmlldyNuYXRpdmUtcGFyc2UtaXNzdWUnLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy50aW1lcGlja2VyLnNldEhvc3QodGhpcy5ob3N0UmVmKTtcbiAgICBpZiAodGhpcy5pbnB1dFZhbHVlKSB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLmRhdGVTZXJ2aWNlLmdldElkKCkgPT09ICduYXRpdmUnID8gdGhpcy5wYXJzZU5hdGl2ZURhdGVTdHJpbmcodGhpcy5pbnB1dFZhbHVlKSA6IHRoaXMuaW5wdXRWYWx1ZTtcbiAgICAgIHRoaXMudGltZXBpY2tlci5kYXRlID0gdGhpcy5kYXRlU2VydmljZS5wYXJzZSh2YWwsIHRoaXMudGltZXBpY2tlci5jb21wdXRlZFRpbWVGb3JtYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRpbWVwaWNrZXIuZGF0ZSA9IHRoaXMuY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlLmdldFJlc2V0VGltZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBpbml0T3ZlcmxheSgpIHtcbiAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICB0aGlzLnN1YnNjcmliZU9uQXBwbHlDbGljaygpO1xuICAgIHRoaXMuY3JlYXRlT3ZlcmxheSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN1YnNjcmliZU9uQXBwbHlDbGljaygpIHtcbiAgICB0aGlzLnRpbWVwaWNrZXIub25TZWxlY3RUaW1lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKHZhbHVlOiBOYlNlbGVjdGVkVGltZVBheWxvYWQ8RD4pID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmRhdGVTZXJ2aWNlLmZvcm1hdCh2YWx1ZS50aW1lLCB0aGlzLnRpbWVwaWNrZXIuY29tcHV0ZWRUaW1lRm9ybWF0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdGhpcy5pbnB1dFZhbHVlID0gdGltZTtcbiAgICAgIHRoaXMudGltZXBpY2tlci5kYXRlID0gdmFsdWUudGltZTtcbiAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUudGltZSk7XG4gICAgICBpZiAodmFsdWUuc2F2ZSkge1xuICAgICAgICB0aGlzLmxhc3RJbnB1dFZhbHVlID0gdGltZTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY3JlYXRlT3ZlcmxheSgpIHtcbiAgICBjb25zdCBzY3JvbGxTdHJhdGVneSA9IHRoaXMuY3JlYXRlU2Nyb2xsU3RyYXRlZ3koKTtcbiAgICB0aGlzLm92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKHsgcG9zaXRpb25TdHJhdGVneTogdGhpcy5wb3NpdGlvblN0cmF0ZWd5LCBzY3JvbGxTdHJhdGVneSB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdWJzY3JpYmVPblRyaWdnZXJzKCkge1xuICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LnNob3ckLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMuaXNDbG9zZWQpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zaG93KCkpO1xuXG4gICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kuaGlkZSQucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5pc09wZW4pKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5pbnB1dFZhbHVlID0gdGhpcy5sYXN0SW5wdXRWYWx1ZSB8fCAnJztcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNyZWF0ZVRyaWdnZXJTdHJhdGVneSgpOiBOYlRyaWdnZXJTdHJhdGVneSB7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlclN0cmF0ZWd5QnVpbGRlclxuICAgICAgLnRyaWdnZXIoTmJUcmlnZ2VyLkZPQ1VTKVxuICAgICAgLmhvc3QodGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAuY29udGFpbmVyKCgpID0+IHRoaXMuZ2V0Q29udGFpbmVyKCkpXG4gICAgICAuYnVpbGQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCk6IE5iQWRqdXN0YWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uQnVpbGRlclxuICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuaG9zdFJlZilcbiAgICAgIC5wb3NpdGlvbihOYlBvc2l0aW9uLkJPVFRPTSlcbiAgICAgIC5vZmZzZXQodGhpcy5vdmVybGF5T2Zmc2V0KVxuICAgICAgLmFkanVzdG1lbnQoTmJBZGp1c3RtZW50LkNPVU5URVJDTE9DS1dJU0UpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5vdmVybGF5UmVmICYmXG4gICAgICB0aGlzLmlzT3BlbiAmJlxuICAgICAgPENvbXBvbmVudFJlZjxhbnk+PntcbiAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICBuYXRpdmVFbGVtZW50OiB0aGlzLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQsXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjcmVhdGVTY3JvbGxTdHJhdGVneSgpOiBOYlNjcm9sbFN0cmF0ZWd5IHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdWJzY3JpYmVPbklucHV0Q2hhbmdlKCkge1xuICAgIGZyb21FdmVudCh0aGlzLmlucHV0LCAnaW5wdXQnKVxuICAgICAgLnBpcGUoXG4gICAgICAgIG1hcCgoKSA9PiB0aGlzLmlucHV0VmFsdWUpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCh2YWx1ZTogc3RyaW5nKSA9PiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlKHZhbHVlKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3Vic2NyaWJlVG9CbHVyKCkge1xuICAgIG1lcmdlKFxuICAgICAgdGhpcy50aW1lcGlja2VyLmJsdXIsXG4gICAgICBmcm9tRXZlbnQodGhpcy5pbnB1dCwgJ2JsdXInKS5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5pc09wZW4gJiYgdGhpcy5kb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmlucHV0KSksXG4gICAgKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uVG91Y2hlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgaW5wdXQgdmFsdWUgYW5kIHdyaXRlIGlmIGl0IGlzbid0IG51bGwuXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICogKi9cbiAgcHJvdGVjdGVkIGhhbmRsZUlucHV0Q2hhbmdlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5kYXRlU2VydmljZS5nZXRJZCgpID09PSAnbmF0aXZlJykge1xuICAgICAgLyoqXG4gICAgICAgKiBOYXRpdmUgZGF0ZSBzZXJ2aWNlIGRvbnQgcGFyc2Ugb25seSB0aW1lIHN0cmluZyB2YWx1ZSxcbiAgICAgICAqIGFuZCB3ZSBhZGRpbmcgeWVhciBtb3V0aCBhbmQgZGF5IHRvIGNvbnZlcnQgc3RyaW5nIHRvIHZhbGlkIGRhdGUgZm9ybWF0XG4gICAgICAgKiovXG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2VOYXRpdmVEYXRlU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1ZhbGlkRGF0ZTogYm9vbGVhbiA9IHRoaXMuZGF0ZVNlcnZpY2UuaXNWYWxpZERhdGVTdHJpbmcodmFsdWUsIHRoaXMudGltZXBpY2tlci5jb21wdXRlZFRpbWVGb3JtYXQpO1xuICAgIGlmIChpc1ZhbGlkRGF0ZSkge1xuICAgICAgdGhpcy5sYXN0SW5wdXRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlU2VydmljZS5wYXJzZSh2YWx1ZSwgdGhpcy50aW1lcGlja2VyLmNvbXB1dGVkVGltZUZvcm1hdCk7XG4gICAgICB0aGlzLm9uQ2hhbmdlKGRhdGUpO1xuICAgICAgdGhpcy50aW1lcGlja2VyLmRhdGUgPSBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCB1cGRhdGVWYWx1ZSh2YWx1ZTogRCkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy50aW1lcGlja2VyLmRhdGUgPSB2YWx1ZTtcblxuICAgICAgY29uc3QgdGltZVN0cmluZyA9IHRoaXMuZGF0ZVNlcnZpY2UuZm9ybWF0KHZhbHVlLCB0aGlzLnRpbWVwaWNrZXIuY29tcHV0ZWRUaW1lRm9ybWF0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdGhpcy5pbnB1dFZhbHVlID0gdGltZVN0cmluZztcbiAgICAgIHRoaXMubGFzdElucHV0VmFsdWUgPSB0aW1lU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIHdyaXRlVmFsdWUodmFsdWU6IEQpOiB2b2lkIHtcbiAgICB0aGlzLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICh2YWx1ZTogYW55KSA9PiB7fSk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5pbnB1dC5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgcGFyc2VOYXRpdmVEYXRlU3RyaW5nKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCk7XG4gICAgY29uc3QgeWVhciA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0WWVhcihkYXRlKTtcbiAgICBjb25zdCBtb250aCA9IHRoaXMuY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlLnBhZGRUb1R3b1N5bWJvbHModGhpcy5kYXRlU2VydmljZS5nZXRNb250aChkYXRlKSk7XG4gICAgY29uc3QgZGF5ID0gdGhpcy5jYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UucGFkZFRvVHdvU3ltYm9scyh0aGlzLmRhdGVTZXJ2aWNlLmdldERhdGUoZGF0ZSkpO1xuXG4gICAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fSAke3ZhbHVlfWA7XG4gIH1cbn1cbiJdfQ==