import { Directive, Input, HostListener, EventEmitter, Output, ContentChildren, } from '@angular/core';
import { forkJoin, of as observableOf, interval, timer, Subject, merge, BehaviorSubject } from 'rxjs';
import { filter, switchMap, map, takeUntil, take, throttle } from 'rxjs/operators';
import { convertToBoolProperty } from '../helpers';
import { NbListItemComponent } from './list.component';
import * as i0 from "@angular/core";
import * as i1 from "../../services/scroll.service";
import * as i2 from "../../services/ruler.service";
export class NbScrollableContainerDimensions {
}
/**
 * Infinite List Directive
 *
 * ```html
 *  <nb-list nbInfiniteList [threshold]="500" (bottomThreshold)="loadNext()">
 *    <nb-list-item *ngFor="let item of items"></nb-list-item>
 *  </nb-list>
 * ```
 *
 * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)
 *
 * Directive will notify when list scrolled up or down to a given threshold.
 * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.
 *
 * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)
 *
 * To improve UX of infinite lists, it's better to keep current page in url,
 * so user able to return to the last viewed page or to share a link to this page.
 * `nbListPageTracker` directive will help you to know, what page user currently viewing.
 * Just put it on a list, set page size and it will calculate page that currently in viewport.
 * You can [open the example](example/infinite-list/infinite-news-list.component)
 * in a new tab to check out this feature.
 *
 * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)
 *
 * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)
 *
 */
export class NbInfiniteListDirective {
    get elementScroll() {
        return !this.windowScroll;
    }
    /**
     * Prevent subsequent bottom/topThreshold emissions for specified duration after emitting once.
     * In milliseconds.
     */
    set throttleTime(value) {
        this.throttleTime$.next(value);
    }
    get throttleTime() {
        return this.throttleTime$.value;
    }
    /**
     * By default component observes list scroll position.
     * If set to `true`, component will observe position of page scroll instead.
     */
    set listenWindowScroll(value) {
        this.windowScroll = convertToBoolProperty(value);
    }
    onElementScroll() {
        if (this.elementScroll) {
            this.elementScroll$.next();
        }
    }
    constructor(elementRef, scrollService, dimensionsService) {
        this.elementRef = elementRef;
        this.scrollService = scrollService;
        this.dimensionsService = dimensionsService;
        this.destroy$ = new Subject();
        this.windowScroll = false;
        this.elementScroll$ = new Subject();
        this.windowScroll$ = this.scrollService.onScroll().pipe(filter(() => this.windowScroll));
        this.bottomThreshold$ = new Subject();
        this.topThreshold$ = new Subject();
        this.throttleTime$ = new BehaviorSubject(0);
        /**
         * Emits when distance between list bottom and current scroll position is less than threshold.
         */
        this.bottomThreshold = new EventEmitter(true);
        /**
         * Emits when distance between list top and current scroll position is less than threshold.
         */
        this.topThreshold = new EventEmitter(true);
    }
    ngAfterViewInit() {
        merge(this.windowScroll$, this.elementScroll$)
            .pipe(switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$))
            .subscribe((dimensions) => this.checkPosition(dimensions));
        this.throttleTime$
            .pipe(switchMap(() => this.topThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$))
            .subscribe(() => {
            this.topThreshold.emit();
        });
        this.throttleTime$
            .pipe(switchMap(() => this.bottomThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$))
            .subscribe(() => {
            this.bottomThreshold.emit();
        });
        this.listItems.changes
            .pipe(
        // For some reason, changes are emitted before list item removed from dom,
        // so dimensions will be incorrect.
        // Check every 50ms for a second if dom and query are in sync.
        // Once they synchronized, we can get proper dimensions.
        switchMap(() => interval(50).pipe(filter(() => this.inSyncWithDom()), take(1), takeUntil(timer(1000)))), switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$))
            .subscribe((dimensions) => this.checkPosition(dimensions));
        this.getContainerDimensions().subscribe((dimensions) => this.checkPosition(dimensions));
    }
    ngOnDestroy() {
        this.topThreshold$.complete();
        this.bottomThreshold$.complete();
        this.elementScroll$.complete();
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkPosition({ scrollHeight, scrollTop, clientHeight }) {
        const initialCheck = this.lastScrollPosition == null;
        const manualCheck = this.lastScrollPosition === scrollTop;
        const scrollUp = scrollTop < this.lastScrollPosition;
        const scrollDown = scrollTop > this.lastScrollPosition;
        const distanceToBottom = scrollHeight - scrollTop - clientHeight;
        if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {
            this.bottomThreshold$.next();
        }
        if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {
            this.topThreshold$.next();
        }
        this.lastScrollPosition = scrollTop;
    }
    getContainerDimensions() {
        if (this.elementScroll) {
            const { scrollTop, scrollHeight, clientHeight } = this.elementRef.nativeElement;
            return observableOf({ scrollTop, scrollHeight, clientHeight });
        }
        return forkJoin([this.scrollService.getPosition(), this.dimensionsService.getDimensions()]).pipe(map(([scrollPosition, dimensions]) => ({
            scrollTop: scrollPosition.y,
            scrollHeight: dimensions.scrollHeight,
            clientHeight: dimensions.clientHeight,
        })));
    }
    inSyncWithDom() {
        return this.elementRef.nativeElement.children.length === this.listItems.length;
    }
}
NbInfiniteListDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbInfiniteListDirective, deps: [{ token: i0.ElementRef }, { token: i1.NbLayoutScrollService }, { token: i2.NbLayoutRulerService }], target: i0.ɵɵFactoryTarget.Directive });
NbInfiniteListDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: NbInfiniteListDirective, selector: "[nbInfiniteList]", inputs: { threshold: "threshold", throttleTime: "throttleTime", listenWindowScroll: "listenWindowScroll" }, outputs: { bottomThreshold: "bottomThreshold", topThreshold: "topThreshold" }, host: { listeners: { "scroll": "onElementScroll()" } }, queries: [{ propertyName: "listItems", predicate: NbListItemComponent }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbInfiniteListDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nbInfiniteList]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.NbLayoutScrollService }, { type: i2.NbLayoutRulerService }]; }, propDecorators: { threshold: [{
                type: Input
            }], throttleTime: [{
                type: Input
            }], listenWindowScroll: [{
                type: Input
            }], bottomThreshold: [{
                type: Output
            }], topThreshold: [{
                type: Output
            }], onElementScroll: [{
                type: HostListener,
                args: ['scroll']
            }], listItems: [{
                type: ContentChildren,
                args: [NbListItemComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5maW5pdGUtbGlzdC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL3RoZW1lL2NvbXBvbmVudHMvbGlzdC9pbmZpbml0ZS1saXN0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxZQUFZLEVBRVosWUFBWSxFQUNaLE1BQU0sRUFHTixlQUFlLEdBRWhCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYyxRQUFRLEVBQUUsRUFBRSxJQUFJLFlBQVksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xILE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ25GLE9BQU8sRUFBRSxxQkFBcUIsRUFBa0IsTUFBTSxZQUFZLENBQUM7QUFHbkUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7QUFFdkQsTUFBTSxPQUFPLCtCQUErQjtDQUkzQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyQkc7QUFJSCxNQUFNLE9BQU8sdUJBQXVCO0lBSWxDLElBQVksYUFBYTtRQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUM1QixDQUFDO0lBY0Q7OztPQUdHO0lBQ0gsSUFDSSxZQUFZLENBQUMsS0FBYTtRQUM1QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFDSSxrQkFBa0IsQ0FBQyxLQUFLO1FBQzFCLElBQUksQ0FBQyxZQUFZLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQWdCRCxlQUFlO1FBQ2IsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDNUI7SUFDSCxDQUFDO0lBSUQsWUFDVSxVQUFzQixFQUN0QixhQUFvQyxFQUNwQyxpQkFBdUM7UUFGdkMsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixrQkFBYSxHQUFiLGFBQWEsQ0FBdUI7UUFDcEMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFzQjtRQWpFekMsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFFdkMsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFJYixtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFDckMsa0JBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDcEYscUJBQWdCLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUN2QyxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFDcEMsa0JBQWEsR0FBRyxJQUFJLGVBQWUsQ0FBUyxDQUFDLENBQUMsQ0FBQztRQStCdkQ7O1dBRUc7UUFFSCxvQkFBZSxHQUFHLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXpDOztXQUVHO1FBRUgsaUJBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQWVuQyxDQUFDO0lBRUosZUFBZTtRQUNiLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUM7YUFDM0MsSUFBSSxDQUNILFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxFQUM5QyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUN6QjthQUNBLFNBQVMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBRTdELElBQUksQ0FBQyxhQUFhO2FBQ2YsSUFBSSxDQUNILFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDckYsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FDekI7YUFDQSxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ2QsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FBQztRQUVMLElBQUksQ0FBQyxhQUFhO2FBQ2YsSUFBSSxDQUNILFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUN4RixTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUN6QjthQUNBLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDZCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzlCLENBQUMsQ0FBQyxDQUFDO1FBRUwsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPO2FBQ25CLElBQUk7UUFDSCwwRUFBMEU7UUFDMUUsbUNBQW1DO1FBQ25DLDhEQUE4RDtRQUM5RCx3REFBd0Q7UUFDeEQsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUNiLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQ2YsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxFQUNsQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQ1AsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUN2QixDQUNGLEVBQ0QsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLEVBQzlDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQ3pCO2FBQ0EsU0FBUyxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFFN0QsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDMUYsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRUQsYUFBYSxDQUFDLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQW1DO1FBQ3RGLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUM7UUFDckQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixLQUFLLFNBQVMsQ0FBQztRQUMxRCxNQUFNLFFBQVEsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDO1FBQ3JELE1BQU0sVUFBVSxHQUFHLFNBQVMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUM7UUFDdkQsTUFBTSxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsU0FBUyxHQUFHLFlBQVksQ0FBQztRQUVqRSxJQUFJLENBQUMsWUFBWSxJQUFJLFdBQVcsSUFBSSxVQUFVLENBQUMsSUFBSSxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ3JGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUM5QjtRQUVELElBQUksQ0FBQyxZQUFZLElBQUksUUFBUSxDQUFDLElBQUksU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDN0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUMzQjtRQUVELElBQUksQ0FBQyxrQkFBa0IsR0FBRyxTQUFTLENBQUM7SUFDdEMsQ0FBQztJQUVPLHNCQUFzQjtRQUM1QixJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEIsTUFBTSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7WUFDaEYsT0FBTyxZQUFZLENBQUMsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxDQUFDLENBQUM7U0FDaEU7UUFFRCxPQUFPLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQzlGLEdBQUcsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3JDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUMzQixZQUFZLEVBQUUsVUFBVSxDQUFDLFlBQVk7WUFDckMsWUFBWSxFQUFFLFVBQVUsQ0FBQyxZQUFZO1NBQ3RDLENBQUMsQ0FBQyxDQUNKLENBQUM7SUFDSixDQUFDO0lBRU8sYUFBYTtRQUNuQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7SUFDakYsQ0FBQzs7b0hBL0pVLHVCQUF1Qjt3R0FBdkIsdUJBQXVCLHFVQTZEakIsbUJBQW1COzJGQTdEekIsdUJBQXVCO2tCQUhuQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxrQkFBa0I7aUJBQzdCO3dLQW1CQyxTQUFTO3NCQURSLEtBQUs7Z0JBUUYsWUFBWTtzQkFEZixLQUFLO2dCQWFGLGtCQUFrQjtzQkFEckIsS0FBSztnQkFVTixlQUFlO3NCQURkLE1BQU07Z0JBT1AsWUFBWTtzQkFEWCxNQUFNO2dCQUlQLGVBQWU7c0JBRGQsWUFBWTt1QkFBQyxRQUFRO2dCQU9nQixTQUFTO3NCQUE5QyxlQUFlO3VCQUFDLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgSW5wdXQsXG4gIEhvc3RMaXN0ZW5lcixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBPdXRwdXQsXG4gIE9uRGVzdHJveSxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZm9ya0pvaW4sIG9mIGFzIG9ic2VydmFibGVPZiwgaW50ZXJ2YWwsIHRpbWVyLCBTdWJqZWN0LCBtZXJnZSwgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHN3aXRjaE1hcCwgbWFwLCB0YWtlVW50aWwsIHRha2UsIHRocm90dGxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgY29udmVydFRvQm9vbFByb3BlcnR5LCBOYkJvb2xlYW5JbnB1dCB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgTmJMYXlvdXRTY3JvbGxTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvc2Nyb2xsLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmJMYXlvdXRSdWxlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9ydWxlci5zZXJ2aWNlJztcbmltcG9ydCB7IE5iTGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2xpc3QuY29tcG9uZW50JztcblxuZXhwb3J0IGNsYXNzIE5iU2Nyb2xsYWJsZUNvbnRhaW5lckRpbWVuc2lvbnMge1xuICBzY3JvbGxUb3A6IG51bWJlcjtcbiAgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XG4gIGNsaWVudEhlaWdodDogbnVtYmVyO1xufVxuXG4vKipcbiAqIEluZmluaXRlIExpc3QgRGlyZWN0aXZlXG4gKlxuICogYGBgaHRtbFxuICogIDxuYi1saXN0IG5iSW5maW5pdGVMaXN0IFt0aHJlc2hvbGRdPVwiNTAwXCIgKGJvdHRvbVRocmVzaG9sZCk9XCJsb2FkTmV4dCgpXCI+XG4gKiAgICA8bmItbGlzdC1pdGVtICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+PC9uYi1saXN0LWl0ZW0+XG4gKiAgPC9uYi1saXN0PlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaW1wbGUgaW5maW5pdGUgbGlzdCwgaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1saXN0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBEaXJlY3RpdmUgd2lsbCBub3RpZnkgd2hlbiBsaXN0IHNjcm9sbGVkIHVwIG9yIGRvd24gdG8gYSBnaXZlbiB0aHJlc2hvbGQuXG4gKiBCeSBkZWZhdWx0IGl0IGxpc3RlbiB0byBzY3JvbGwgb2YgbGlzdCBvbiB3aGljaCBhcHBsaWVkLCBidXQgYWxzbyBjYW4gYmUgc2V0IHRvIGxpc3RlbiB0byB3aW5kb3cgc2Nyb2xsLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2Nyb2xsIG1vZGVzLCBpbmZpbml0ZS1saXN0L2luZmluaXRlLWxpc3Qtc2Nyb2xsLW1vZGVzLmNvbXBvbmVudClcbiAqXG4gKiBUbyBpbXByb3ZlIFVYIG9mIGluZmluaXRlIGxpc3RzLCBpdCdzIGJldHRlciB0byBrZWVwIGN1cnJlbnQgcGFnZSBpbiB1cmwsXG4gKiBzbyB1c2VyIGFibGUgdG8gcmV0dXJuIHRvIHRoZSBsYXN0IHZpZXdlZCBwYWdlIG9yIHRvIHNoYXJlIGEgbGluayB0byB0aGlzIHBhZ2UuXG4gKiBgbmJMaXN0UGFnZVRyYWNrZXJgIGRpcmVjdGl2ZSB3aWxsIGhlbHAgeW91IHRvIGtub3csIHdoYXQgcGFnZSB1c2VyIGN1cnJlbnRseSB2aWV3aW5nLlxuICogSnVzdCBwdXQgaXQgb24gYSBsaXN0LCBzZXQgcGFnZSBzaXplIGFuZCBpdCB3aWxsIGNhbGN1bGF0ZSBwYWdlIHRoYXQgY3VycmVudGx5IGluIHZpZXdwb3J0LlxuICogWW91IGNhbiBbb3BlbiB0aGUgZXhhbXBsZV0oZXhhbXBsZS9pbmZpbml0ZS1saXN0L2luZmluaXRlLW5ld3MtbGlzdC5jb21wb25lbnQpXG4gKiBpbiBhIG5ldyB0YWIgdG8gY2hlY2sgb3V0IHRoaXMgZmVhdHVyZS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEluZmluaXRlIGxpc3Qgd2l0aCBwYWdlciwgaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1uZXdzLWxpc3QuY29tcG9uZW50KVxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSW5maW5pdGUgbGlzdCB3aXRoIHBsYWNlaG9sZGVycyBhdCB0aGUgdG9wLCBpbmZpbml0ZS1saXN0L2luZmluaXRlLWxpc3QtcGxhY2Vob2xkZXJzLmNvbXBvbmVudClcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuYkluZmluaXRlTGlzdF0nLFxufSlcbmV4cG9ydCBjbGFzcyBOYkluZmluaXRlTGlzdERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwcml2YXRlIGxhc3RTY3JvbGxQb3NpdGlvbjtcbiAgd2luZG93U2Nyb2xsID0gZmFsc2U7XG4gIHByaXZhdGUgZ2V0IGVsZW1lbnRTY3JvbGwoKSB7XG4gICAgcmV0dXJuICF0aGlzLndpbmRvd1Njcm9sbDtcbiAgfVxuICBwcml2YXRlIGVsZW1lbnRTY3JvbGwkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHJpdmF0ZSB3aW5kb3dTY3JvbGwkID0gdGhpcy5zY3JvbGxTZXJ2aWNlLm9uU2Nyb2xsKCkucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy53aW5kb3dTY3JvbGwpKTtcbiAgcHJpdmF0ZSBib3R0b21UaHJlc2hvbGQkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHJpdmF0ZSB0b3BUaHJlc2hvbGQkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHJpdmF0ZSB0aHJvdHRsZVRpbWUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KDApO1xuXG4gIC8qKlxuICAgKiBUaHJlc2hvbGQgYWZ0ZXIgd2hpY2ggZXZlbnQgbG9hZCBtb3JlIGV2ZW50IHdpbGwgYmUgZW1pdGVkLlxuICAgKiBJbiBwaXhlbHMuXG4gICAqL1xuICBASW5wdXQoKVxuICB0aHJlc2hvbGQ6IG51bWJlcjtcblxuICAvKipcbiAgICogUHJldmVudCBzdWJzZXF1ZW50IGJvdHRvbS90b3BUaHJlc2hvbGQgZW1pc3Npb25zIGZvciBzcGVjaWZpZWQgZHVyYXRpb24gYWZ0ZXIgZW1pdHRpbmcgb25jZS5cbiAgICogSW4gbWlsbGlzZWNvbmRzLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IHRocm90dGxlVGltZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy50aHJvdHRsZVRpbWUkLm5leHQodmFsdWUpO1xuICB9XG4gIGdldCB0aHJvdHRsZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhyb3R0bGVUaW1lJC52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IGNvbXBvbmVudCBvYnNlcnZlcyBsaXN0IHNjcm9sbCBwb3NpdGlvbi5cbiAgICogSWYgc2V0IHRvIGB0cnVlYCwgY29tcG9uZW50IHdpbGwgb2JzZXJ2ZSBwb3NpdGlvbiBvZiBwYWdlIHNjcm9sbCBpbnN0ZWFkLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGxpc3RlbldpbmRvd1Njcm9sbCh2YWx1ZSkge1xuICAgIHRoaXMud2luZG93U2Nyb2xsID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbGlzdGVuV2luZG93U2Nyb2xsOiBOYkJvb2xlYW5JbnB1dDtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiBkaXN0YW5jZSBiZXR3ZWVuIGxpc3QgYm90dG9tIGFuZCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gdGhyZXNob2xkLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGJvdHRvbVRocmVzaG9sZCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gZGlzdGFuY2UgYmV0d2VlbiBsaXN0IHRvcCBhbmQgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaXMgbGVzcyB0aGFuIHRocmVzaG9sZC5cbiAgICovXG4gIEBPdXRwdXQoKVxuICB0b3BUaHJlc2hvbGQgPSBuZXcgRXZlbnRFbWl0dGVyKHRydWUpO1xuXG4gIEBIb3N0TGlzdGVuZXIoJ3Njcm9sbCcpXG4gIG9uRWxlbWVudFNjcm9sbCgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50U2Nyb2xsKSB7XG4gICAgICB0aGlzLmVsZW1lbnRTY3JvbGwkLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKE5iTGlzdEl0ZW1Db21wb25lbnQpIGxpc3RJdGVtczogUXVlcnlMaXN0PE5iTGlzdEl0ZW1Db21wb25lbnQ+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHNjcm9sbFNlcnZpY2U6IE5iTGF5b3V0U2Nyb2xsU2VydmljZSxcbiAgICBwcml2YXRlIGRpbWVuc2lvbnNTZXJ2aWNlOiBOYkxheW91dFJ1bGVyU2VydmljZSxcbiAgKSB7fVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBtZXJnZSh0aGlzLndpbmRvd1Njcm9sbCQsIHRoaXMuZWxlbWVudFNjcm9sbCQpXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuZ2V0Q29udGFpbmVyRGltZW5zaW9ucygpKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoZGltZW5zaW9ucykgPT4gdGhpcy5jaGVja1Bvc2l0aW9uKGRpbWVuc2lvbnMpKTtcblxuICAgIHRoaXMudGhyb3R0bGVUaW1lJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0aGlzLnRvcFRocmVzaG9sZCQucGlwZSh0aHJvdHRsZSgoKSA9PiBpbnRlcnZhbCh0aGlzLnRocm90dGxlVGltZSkpKSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnRvcFRocmVzaG9sZC5lbWl0KCk7XG4gICAgICB9KTtcblxuICAgIHRoaXMudGhyb3R0bGVUaW1lJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0aGlzLmJvdHRvbVRocmVzaG9sZCQucGlwZSh0aHJvdHRsZSgoKSA9PiBpbnRlcnZhbCh0aGlzLnRocm90dGxlVGltZSkpKSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmJvdHRvbVRocmVzaG9sZC5lbWl0KCk7XG4gICAgICB9KTtcblxuICAgIHRoaXMubGlzdEl0ZW1zLmNoYW5nZXNcbiAgICAgIC5waXBlKFxuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIGNoYW5nZXMgYXJlIGVtaXR0ZWQgYmVmb3JlIGxpc3QgaXRlbSByZW1vdmVkIGZyb20gZG9tLFxuICAgICAgICAvLyBzbyBkaW1lbnNpb25zIHdpbGwgYmUgaW5jb3JyZWN0LlxuICAgICAgICAvLyBDaGVjayBldmVyeSA1MG1zIGZvciBhIHNlY29uZCBpZiBkb20gYW5kIHF1ZXJ5IGFyZSBpbiBzeW5jLlxuICAgICAgICAvLyBPbmNlIHRoZXkgc3luY2hyb25pemVkLCB3ZSBjYW4gZ2V0IHByb3BlciBkaW1lbnNpb25zLlxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICBpbnRlcnZhbCg1MCkucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLmluU3luY1dpdGhEb20oKSksXG4gICAgICAgICAgICB0YWtlKDEpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRpbWVyKDEwMDApKSxcbiAgICAgICAgICApLFxuICAgICAgICApLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5nZXRDb250YWluZXJEaW1lbnNpb25zKCkpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChkaW1lbnNpb25zKSA9PiB0aGlzLmNoZWNrUG9zaXRpb24oZGltZW5zaW9ucykpO1xuXG4gICAgdGhpcy5nZXRDb250YWluZXJEaW1lbnNpb25zKCkuc3Vic2NyaWJlKChkaW1lbnNpb25zKSA9PiB0aGlzLmNoZWNrUG9zaXRpb24oZGltZW5zaW9ucykpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy50b3BUaHJlc2hvbGQkLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5ib3R0b21UaHJlc2hvbGQkLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5lbGVtZW50U2Nyb2xsJC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgfVxuXG4gIGNoZWNrUG9zaXRpb24oeyBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCwgY2xpZW50SGVpZ2h0IH06IE5iU2Nyb2xsYWJsZUNvbnRhaW5lckRpbWVuc2lvbnMpIHtcbiAgICBjb25zdCBpbml0aWFsQ2hlY2sgPSB0aGlzLmxhc3RTY3JvbGxQb3NpdGlvbiA9PSBudWxsO1xuICAgIGNvbnN0IG1hbnVhbENoZWNrID0gdGhpcy5sYXN0U2Nyb2xsUG9zaXRpb24gPT09IHNjcm9sbFRvcDtcbiAgICBjb25zdCBzY3JvbGxVcCA9IHNjcm9sbFRvcCA8IHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IHNjcm9sbERvd24gPSBzY3JvbGxUb3AgPiB0aGlzLmxhc3RTY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCBkaXN0YW5jZVRvQm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gY2xpZW50SGVpZ2h0O1xuXG4gICAgaWYgKChpbml0aWFsQ2hlY2sgfHwgbWFudWFsQ2hlY2sgfHwgc2Nyb2xsRG93bikgJiYgZGlzdGFuY2VUb0JvdHRvbSA8PSB0aGlzLnRocmVzaG9sZCkge1xuICAgICAgdGhpcy5ib3R0b21UaHJlc2hvbGQkLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAoKGluaXRpYWxDaGVjayB8fCBzY3JvbGxVcCkgJiYgc2Nyb2xsVG9wIDw9IHRoaXMudGhyZXNob2xkKSB7XG4gICAgICB0aGlzLnRvcFRocmVzaG9sZCQubmV4dCgpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uID0gc2Nyb2xsVG9wO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb250YWluZXJEaW1lbnNpb25zKCk6IE9ic2VydmFibGU8TmJTY3JvbGxhYmxlQ29udGFpbmVyRGltZW5zaW9ucz4ge1xuICAgIGlmICh0aGlzLmVsZW1lbnRTY3JvbGwpIHtcbiAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ya0pvaW4oW3RoaXMuc2Nyb2xsU2VydmljZS5nZXRQb3NpdGlvbigpLCB0aGlzLmRpbWVuc2lvbnNTZXJ2aWNlLmdldERpbWVuc2lvbnMoKV0pLnBpcGUoXG4gICAgICBtYXAoKFtzY3JvbGxQb3NpdGlvbiwgZGltZW5zaW9uc10pID0+ICh7XG4gICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsUG9zaXRpb24ueSxcbiAgICAgICAgc2Nyb2xsSGVpZ2h0OiBkaW1lbnNpb25zLnNjcm9sbEhlaWdodCxcbiAgICAgICAgY2xpZW50SGVpZ2h0OiBkaW1lbnNpb25zLmNsaWVudEhlaWdodCxcbiAgICAgIH0pKSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBpblN5bmNXaXRoRG9tKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IHRoaXMubGlzdEl0ZW1zLmxlbmd0aDtcbiAgfVxufVxuIl19