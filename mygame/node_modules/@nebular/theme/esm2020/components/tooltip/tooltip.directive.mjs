/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { Directive, Input, Output, EventEmitter, } from '@angular/core';
import { skip, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
import { NbAdjustment, NbPosition } from '../cdk/overlay/overlay-position';
import { NbTrigger } from '../cdk/overlay/overlay-trigger';
import { NbDynamicOverlay } from '../cdk/overlay/dynamic/dynamic-overlay';
import { NbDynamicOverlayHandler } from '../cdk/overlay/dynamic/dynamic-overlay-handler';
import { NbTooltipComponent } from './tooltip.component';
import * as i0 from "@angular/core";
import * as i1 from "../cdk/overlay/dynamic/dynamic-overlay-handler";
/**
 *
 * Tooltip directive for small text/icon hints.
 *
 * ### Installation
 *
 * Import `NbTooltipModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTooltipModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * @stacked-example(Showcase, tooltip/tooltip-showcase.component)
 *
 * Tooltip can accept a hint text and/or an icon:
 * @stacked-example(With Icon, tooltip/tooltip-with-icon.component)
 *
 * Same way as Popover, tooltip can accept placement position with `nbTooltipPlacement` property:
 * @stacked-example(Placements, tooltip/tooltip-placements.component)
 *
 * It is also possible to specify tooltip color using `nbTooltipStatus` property:
 * @stacked-example(Colored Tooltips, tooltip/tooltip-colors.component)
 *
 * Tooltip has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 */
export class NbTooltipDirective {
    /**
     * Container position will change automatically based on this strategy if container can't fit view port.
     * Set this property to `noop` value if you want to disable automatic adjustment.
     * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
     */
    get adjustment() {
        return this._adjustment;
    }
    set adjustment(value) {
        this._adjustment = value;
    }
    get tooltipClass() {
        return this._tooltipClass;
    }
    set tooltipClass(value) {
        if (value !== this.tooltipClass) {
            this._tooltipClass = value;
            this.overlayConfig = { panelClass: this.tooltipClass };
        }
    }
    /**
     * Accepts icon name or icon config object
     * @param {string | NbIconConfig} icon name or config object
     */
    set icon(icon) {
        this.context = Object.assign(this.context, { icon });
    }
    /**
     *
     * @param {string} status
     */
    set status(status) {
        this.context = Object.assign(this.context, { status });
    }
    get isShown() {
        return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
    }
    constructor(hostRef, dynamicOverlayHandler) {
        this.hostRef = hostRef;
        this.dynamicOverlayHandler = dynamicOverlayHandler;
        this.destroy$ = new Subject();
        this.tooltipComponent = NbTooltipComponent;
        this.context = {};
        /**
         * Position will be calculated relatively host element based on the position.
         * Can be top, right, bottom, left, start or end.
         */
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.position = NbPosition.TOP;
        this._adjustment = NbAdjustment.CLOCKWISE;
        this._tooltipClass = '';
        /**
         * Describes when the container will be shown.
         * Available options: `click`, `hover`, `hint`, `focus` and `noop`
         * */
        this.trigger = NbTrigger.HINT;
        /**
         * Determines tooltip overlay offset (in pixels).
         **/
        this.offset = 8;
        /** Disables the display of the tooltip. */
        this.disabled = false;
        this.nbTooltipShowStateChange = new EventEmitter();
        this.overlayConfig = { panelClass: this.tooltipClass };
    }
    ngOnInit() {
        this.dynamicOverlayHandler.host(this.hostRef).componentType(this.tooltipComponent).offset(this.offset);
    }
    ngOnChanges() {
        this.rebuild();
    }
    ngAfterViewInit() {
        this.dynamicOverlay = this.configureDynamicOverlay().build();
        this.dynamicOverlay.isShown
            .pipe(skip(1), takeUntil(this.destroy$))
            .subscribe((isShown) => this.nbTooltipShowStateChange.emit({ isShown }));
    }
    rebuild() {
        this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
    }
    show() {
        this.dynamicOverlay.show();
    }
    hide() {
        this.dynamicOverlay.hide();
    }
    toggle() {
        this.dynamicOverlay.toggle();
    }
    ngOnDestroy() {
        this.dynamicOverlayHandler.destroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    configureDynamicOverlay() {
        return this.dynamicOverlayHandler
            .position(this.position)
            .trigger(this.trigger)
            .disabled(this.disabled)
            .adjustment(this.adjustment)
            .content(this.content)
            .context(this.context)
            .overlayConfig(this.overlayConfig);
    }
}
NbTooltipDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbTooltipDirective, deps: [{ token: i0.ElementRef }, { token: i1.NbDynamicOverlayHandler }], target: i0.ɵɵFactoryTarget.Directive });
NbTooltipDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.4", type: NbTooltipDirective, selector: "[nbTooltip]", inputs: { content: ["nbTooltip", "content"], position: ["nbTooltipPlacement", "position"], adjustment: ["nbTooltipAdjustment", "adjustment"], tooltipClass: ["nbTooltipClass", "tooltipClass"], icon: ["nbTooltipIcon", "icon"], status: ["nbTooltipStatus", "status"], trigger: ["nbTooltipTrigger", "trigger"], offset: ["nbTooltipOffset", "offset"], disabled: ["nbTooltipDisabled", "disabled"] }, outputs: { nbTooltipShowStateChange: "nbTooltipShowStateChange" }, providers: [NbDynamicOverlayHandler, NbDynamicOverlay], exportAs: ["nbTooltip"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbTooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nbTooltip]',
                    exportAs: 'nbTooltip',
                    providers: [NbDynamicOverlayHandler, NbDynamicOverlay],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.NbDynamicOverlayHandler }]; }, propDecorators: { content: [{
                type: Input,
                args: ['nbTooltip']
            }], position: [{
                type: Input,
                args: ['nbTooltipPlacement']
            }], adjustment: [{
                type: Input,
                args: ['nbTooltipAdjustment']
            }], tooltipClass: [{
                type: Input,
                args: ['nbTooltipClass']
            }], icon: [{
                type: Input,
                args: ['nbTooltipIcon']
            }], status: [{
                type: Input,
                args: ['nbTooltipStatus']
            }], trigger: [{
                type: Input,
                args: ['nbTooltipTrigger']
            }], offset: [{
                type: Input,
                args: ['nbTooltipOffset']
            }], disabled: [{
                type: Input,
                args: ['nbTooltipDisabled']
            }], nbTooltipShowStateChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbHRpcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZnJhbWV3b3JrL3RoZW1lL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUVMLFNBQVMsRUFFVCxLQUFLLEVBSUwsTUFBTSxFQUNOLFlBQVksR0FDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFHL0IsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQXdDLE1BQU0saUNBQWlDLENBQUM7QUFDakgsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQzNELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzFFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGdEQUFnRCxDQUFDO0FBRXpGLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7QUFHekQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVDRztBQU1ILE1BQU0sT0FBTyxrQkFBa0I7SUFzQjdCOzs7O09BSUc7SUFDSCxJQUNJLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUNELElBQUksVUFBVSxDQUFDLEtBQW1CO1FBQ2hDLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0lBQzNCLENBQUM7SUFJRCxJQUNJLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDNUIsQ0FBQztJQUNELElBQUksWUFBWSxDQUFDLEtBQWE7UUFDNUIsSUFBSSxLQUFLLEtBQUss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QVV4QixPQUFPO3NCQUROLEtBQUs7dUJBQUMsa0JBQWtCO2dCQU1DLE1BQU07c0JBQS9CLEtBQUs7dUJBQUMsaUJBQWlCO2dCQUdJLFFBQVE7c0JBQW5DLEtBQUs7dUJBQUMsbUJBQW1CO2dCQUcxQix3QkFBd0I7c0JBRHZCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cblxuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgc2tpcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOYkNvbXBvbmVudE9yQ3VzdG9tU3RhdHVzIH0gZnJvbSAnLi4vY29tcG9uZW50LXN0YXR1cyc7XG5pbXBvcnQgeyBOYkFkanVzdG1lbnQsIE5iUG9zaXRpb24sIE5iUG9zaXRpb25WYWx1ZXMsIE5iQWRqdXN0bWVudFZhbHVlcyB9IGZyb20gJy4uL2Nkay9vdmVybGF5L292ZXJsYXktcG9zaXRpb24nO1xuaW1wb3J0IHsgTmJUcmlnZ2VyIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvb3ZlcmxheS10cmlnZ2VyJztcbmltcG9ydCB7IE5iRHluYW1pY092ZXJsYXkgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9keW5hbWljL2R5bmFtaWMtb3ZlcmxheSc7XG5pbXBvcnQgeyBOYkR5bmFtaWNPdmVybGF5SGFuZGxlciB9IGZyb20gJy4uL2Nkay9vdmVybGF5L2R5bmFtaWMvZHluYW1pYy1vdmVybGF5LWhhbmRsZXInO1xuaW1wb3J0IHsgTmJPdmVybGF5Q29uZmlnIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvbWFwcGluZyc7XG5pbXBvcnQgeyBOYlRvb2x0aXBDb21wb25lbnQgfSBmcm9tICcuL3Rvb2x0aXAuY29tcG9uZW50JztcbmltcG9ydCB7IE5iSWNvbkNvbmZpZyB9IGZyb20gJy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBUb29sdGlwIGRpcmVjdGl2ZSBmb3Igc21hbGwgdGV4dC9pY29uIGhpbnRzLlxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iVG9vbHRpcE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUb29sdGlwTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0b29sdGlwL3Rvb2x0aXAtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIFRvb2x0aXAgY2FuIGFjY2VwdCBhIGhpbnQgdGV4dCBhbmQvb3IgYW4gaWNvbjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoV2l0aCBJY29uLCB0b29sdGlwL3Rvb2x0aXAtd2l0aC1pY29uLmNvbXBvbmVudClcbiAqXG4gKiBTYW1lIHdheSBhcyBQb3BvdmVyLCB0b29sdGlwIGNhbiBhY2NlcHQgcGxhY2VtZW50IHBvc2l0aW9uIHdpdGggYG5iVG9vbHRpcFBsYWNlbWVudGAgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFBsYWNlbWVudHMsIHRvb2x0aXAvdG9vbHRpcC1wbGFjZW1lbnRzLmNvbXBvbmVudClcbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHNwZWNpZnkgdG9vbHRpcCBjb2xvciB1c2luZyBgbmJUb29sdGlwU3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ29sb3JlZCBUb29sdGlwcywgdG9vbHRpcC90b29sdGlwLWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogVG9vbHRpcCBoYXMgYSBudW1iZXIgb2YgdHJpZ2dlcnMgd2hpY2ggcHJvdmlkZXMgYW4gYWJpbGl0eSB0byBzaG93IGFuZCBoaWRlIHRoZSBjb21wb25lbnQgaW4gZGlmZmVyZW50IHdheXM6XG4gKlxuICogLSBDbGljayBtb2RlIHNob3dzIHRoZSBjb21wb25lbnQgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIHRoZSBob3N0IGVsZW1lbnQgYW5kIGhpZGVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzXG4gKiBzb21ld2hlcmUgb24gdGhlIGRvY3VtZW50IG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAqIC0gSGludCBwcm92aWRlcyBjYXBhYmlsaXR5IHRvIHNob3cgdGhlIGNvbXBvbmVudCB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIHRoZSBob3N0IGVsZW1lbnRcbiAqIGFuZCBoaWRlIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG91dCBvZiB0aGUgaG9zdC5cbiAqIC0gSG92ZXIgd29ya3MgbGlrZSBoaW50IG1vZGUgd2l0aCBvbmUgZXhjZXB0aW9uIC0gd2hlbiB0aGUgdXNlciBtb3ZlcyBtb3VzZSBmcm9tIGhvc3QgZWxlbWVudCB0b1xuICogdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoZSBjb21wb25lbnQgcmVtYWlucyBvcGVuLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGludGVyYWN0IHdpdGggaXQgY29udGVudC5cbiAqIC0gRm9jdXMgbW9kZSBpcyBhcHBsaWVkIHdoZW4gdXNlciBmb2N1c2VzIHRoZSBlbGVtZW50LlxuICogLSBOb29wIG1vZGUgLSB0aGUgY29tcG9uZW50IHdvbid0IHJlYWN0IHRvIHRoZSB1c2VyIGludGVyYWN0aW9uLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbmJUb29sdGlwXScsXG4gIGV4cG9ydEFzOiAnbmJUb29sdGlwJyxcbiAgcHJvdmlkZXJzOiBbTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIsIE5iRHluYW1pY092ZXJsYXldLFxufSlcbmV4cG9ydCBjbGFzcyBOYlRvb2x0aXBEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgcHJvdGVjdGVkIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgcHJvdGVjdGVkIHRvb2x0aXBDb21wb25lbnQgPSBOYlRvb2x0aXBDb21wb25lbnQ7XG4gIHByb3RlY3RlZCBkeW5hbWljT3ZlcmxheTogTmJEeW5hbWljT3ZlcmxheTtcblxuICBjb250ZXh0OiBPYmplY3QgPSB7fTtcblxuICAvKipcbiAgICogVG9vbHRpcCBtZXNzYWdlXG4gICAqL1xuICBASW5wdXQoJ25iVG9vbHRpcCcpXG4gIGNvbnRlbnQ6IHN0cmluZztcblxuICAvKipcbiAgICogUG9zaXRpb24gd2lsbCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlbHkgaG9zdCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwb3NpdGlvbi5cbiAgICogQ2FuIGJlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQgb3IgZW5kLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9uby1pbnB1dC1yZW5hbWVcbiAgQElucHV0KCduYlRvb2x0aXBQbGFjZW1lbnQnKVxuICBwb3NpdGlvbjogTmJQb3NpdGlvbiA9IE5iUG9zaXRpb24uVE9QO1xuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcG9zaXRpb246IE5iUG9zaXRpb25WYWx1ZXM7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5lciBwb3NpdGlvbiB3aWxsIGNoYW5nZSBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoaXMgc3RyYXRlZ3kgaWYgY29udGFpbmVyIGNhbid0IGZpdCB2aWV3IHBvcnQuXG4gICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGBub29wYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIGF1dG9tYXRpYyBhZGp1c3RtZW50LlxuICAgKiBBdmFpbGFibGUgdmFsdWVzOiBgY2xvY2t3aXNlYCAoZGVmYXVsdCksIGBjb3VudGVyY2xvY2t3aXNlYCwgYHZlcnRpY2FsYCwgYGhvcml6b250YWxgLCBgbm9vcGAuXG4gICAqL1xuICBASW5wdXQoJ25iVG9vbHRpcEFkanVzdG1lbnQnKVxuICBnZXQgYWRqdXN0bWVudCgpOiBOYkFkanVzdG1lbnQge1xuICAgIHJldHVybiB0aGlzLl9hZGp1c3RtZW50O1xuICB9XG4gIHNldCBhZGp1c3RtZW50KHZhbHVlOiBOYkFkanVzdG1lbnQpIHtcbiAgICB0aGlzLl9hZGp1c3RtZW50ID0gdmFsdWU7XG4gIH1cbiAgcHJvdGVjdGVkIF9hZGp1c3RtZW50OiBOYkFkanVzdG1lbnQgPSBOYkFkanVzdG1lbnQuQ0xPQ0tXSVNFO1xuICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfYWRqdXN0bWVudDogTmJBZGp1c3RtZW50VmFsdWVzO1xuXG4gIEBJbnB1dCgnbmJUb29sdGlwQ2xhc3MnKVxuICBnZXQgdG9vbHRpcENsYXNzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3Rvb2x0aXBDbGFzcztcbiAgfVxuICBzZXQgdG9vbHRpcENsYXNzKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMudG9vbHRpcENsYXNzKSB7XG4gICAgICB0aGlzLl90b29sdGlwQ2xhc3MgPSB2YWx1ZTtcbiAgICAgIHRoaXMub3ZlcmxheUNvbmZpZyA9IHsgcGFuZWxDbGFzczogdGhpcy50b29sdGlwQ2xhc3MgfTtcbiAgICB9XG4gIH1cbiAgX3Rvb2x0aXBDbGFzczogc3RyaW5nID0gJyc7XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgaWNvbiBuYW1lIG9yIGljb24gY29uZmlnIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IE5iSWNvbkNvbmZpZ30gaWNvbiBuYW1lIG9yIGNvbmZpZyBvYmplY3RcbiAgICovXG4gIEBJbnB1dCgnbmJUb29sdGlwSWNvbicpXG4gIHNldCBpY29uKGljb246IHN0cmluZyB8IE5iSWNvbkNvbmZpZykge1xuICAgIHRoaXMuY29udGV4dCA9IE9iamVjdC5hc3NpZ24odGhpcy5jb250ZXh0LCB7IGljb24gfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c1xuICAgKi9cbiAgQElucHV0KCduYlRvb2x0aXBTdGF0dXMnKVxuICBzZXQgc3RhdHVzKHN0YXR1czogTmJDb21wb25lbnRPckN1c3RvbVN0YXR1cykge1xuICAgIHRoaXMuY29udGV4dCA9IE9iamVjdC5hc3NpZ24odGhpcy5jb250ZXh0LCB7IHN0YXR1cyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNjcmliZXMgd2hlbiB0aGUgY29udGFpbmVyIHdpbGwgYmUgc2hvd24uXG4gICAqIEF2YWlsYWJsZSBvcHRpb25zOiBgY2xpY2tgLCBgaG92ZXJgLCBgaGludGAsIGBmb2N1c2AgYW5kIGBub29wYFxuICAgKiAqL1xuICBASW5wdXQoJ25iVG9vbHRpcFRyaWdnZXInKVxuICB0cmlnZ2VyOiBOYlRyaWdnZXIgPSBOYlRyaWdnZXIuSElOVDtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0b29sdGlwIG92ZXJsYXkgb2Zmc2V0IChpbiBwaXhlbHMpLlxuICAgKiovXG4gIEBJbnB1dCgnbmJUb29sdGlwT2Zmc2V0Jykgb2Zmc2V0ID0gODtcblxuICAvKiogRGlzYWJsZXMgdGhlIGRpc3BsYXkgb2YgdGhlIHRvb2x0aXAuICovXG4gIEBJbnB1dCgnbmJUb29sdGlwRGlzYWJsZWQnKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoKVxuICBuYlRvb2x0aXBTaG93U3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHsgaXNTaG93bjogYm9vbGVhbiB9PigpO1xuXG4gIHByb3RlY3RlZCBvdmVybGF5Q29uZmlnOiBOYk92ZXJsYXlDb25maWcgPSB7IHBhbmVsQ2xhc3M6IHRoaXMudG9vbHRpcENsYXNzIH07XG5cbiAgZ2V0IGlzU2hvd24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKHRoaXMuZHluYW1pY092ZXJsYXkgJiYgdGhpcy5keW5hbWljT3ZlcmxheS5pc0F0dGFjaGVkKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBob3N0UmVmOiBFbGVtZW50UmVmLCBwcm90ZWN0ZWQgZHluYW1pY092ZXJsYXlIYW5kbGVyOiBOYkR5bmFtaWNPdmVybGF5SGFuZGxlcikge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlci5ob3N0KHRoaXMuaG9zdFJlZikuY29tcG9uZW50VHlwZSh0aGlzLnRvb2x0aXBDb21wb25lbnQpLm9mZnNldCh0aGlzLm9mZnNldCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICB0aGlzLnJlYnVpbGQoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLmR5bmFtaWNPdmVybGF5ID0gdGhpcy5jb25maWd1cmVEeW5hbWljT3ZlcmxheSgpLmJ1aWxkKCk7XG5cbiAgICB0aGlzLmR5bmFtaWNPdmVybGF5LmlzU2hvd25cbiAgICAgIC5waXBlKHNraXAoMSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgIC5zdWJzY3JpYmUoKGlzU2hvd246IGJvb2xlYW4pID0+IHRoaXMubmJUb29sdGlwU2hvd1N0YXRlQ2hhbmdlLmVtaXQoeyBpc1Nob3duIH0pKTtcbiAgfVxuXG4gIHJlYnVpbGQoKSB7XG4gICAgdGhpcy5keW5hbWljT3ZlcmxheSA9IHRoaXMuY29uZmlndXJlRHluYW1pY092ZXJsYXkoKS5yZWJ1aWxkKCk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuZHluYW1pY092ZXJsYXkuc2hvdygpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmR5bmFtaWNPdmVybGF5LmhpZGUoKTtcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLmR5bmFtaWNPdmVybGF5LnRvZ2dsZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb25maWd1cmVEeW5hbWljT3ZlcmxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXJcbiAgICAgIC5wb3NpdGlvbih0aGlzLnBvc2l0aW9uKVxuICAgICAgLnRyaWdnZXIodGhpcy50cmlnZ2VyKVxuICAgICAgLmRpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgICAuYWRqdXN0bWVudCh0aGlzLmFkanVzdG1lbnQpXG4gICAgICAuY29udGVudCh0aGlzLmNvbnRlbnQpXG4gICAgICAuY29udGV4dCh0aGlzLmNvbnRleHQpXG4gICAgICAub3ZlcmxheUNvbmZpZyh0aGlzLm92ZXJsYXlDb25maWcpO1xuICB9XG59XG4iXX0=