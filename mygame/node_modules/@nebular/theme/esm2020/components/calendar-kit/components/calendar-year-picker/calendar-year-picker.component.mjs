/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { ChangeDetectionStrategy, Component, EventEmitter, HostBinding, Input, Output, } from '@angular/core';
import { NbCalendarSize } from '../../model';
import { NbCalendarYearCellComponent } from './calendar-year-cell.component';
import * as i0 from "@angular/core";
import * as i1 from "../../services/date.service";
import * as i2 from "../../services/calendar-year-model.service";
import * as i3 from "../calendar-picker/calendar-picker.component";
export class NbCalendarYearPickerComponent {
    set _cellComponent(cellComponent) {
        if (cellComponent) {
            this.cellComponent = cellComponent;
        }
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    constructor(dateService, yearModelService) {
        this.dateService = dateService;
        this.yearModelService = yearModelService;
        this.cellComponent = NbCalendarYearCellComponent;
        this.size = NbCalendarSize.MEDIUM;
        this.yearChange = new EventEmitter();
    }
    ngOnChanges() {
        this.years = this.yearModelService.getViewYears(this.year);
    }
    onSelect(year) {
        this.yearChange.emit(year);
    }
}
NbCalendarYearPickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbCalendarYearPickerComponent, deps: [{ token: i1.NbDateService }, { token: i2.NbCalendarYearModelService }], target: i0.ɵɵFactoryTarget.Component });
NbCalendarYearPickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.4", type: NbCalendarYearPickerComponent, selector: "nb-calendar-year-picker", inputs: { date: "date", min: "min", max: "max", filter: "filter", _cellComponent: ["cellComponent", "_cellComponent"], size: "size", year: "year" }, outputs: { yearChange: "yearChange" }, host: { properties: { "class.size-large": "this.large" } }, usesOnChanges: true, ngImport: i0, template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `, isInline: true, dependencies: [{ kind: "component", type: i3.NbCalendarPickerComponent, selector: "nb-calendar-picker", inputs: ["data", "visibleDate", "selectedValue", "cellComponent", "min", "max", "filter", "size"], outputs: ["select"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.4", ngImport: i0, type: NbCalendarYearPickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nb-calendar-year-picker',
                    template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.NbDateService }, { type: i2.NbCalendarYearModelService }]; }, propDecorators: { date: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], filter: [{
                type: Input
            }], _cellComponent: [{
                type: Input,
                args: ['cellComponent']
            }], size: [{
                type: Input
            }], year: [{
                type: Input
            }], yearChange: [{
                type: Output
            }], large: [{
                type: HostBinding,
                args: ['class.size-large']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIteWVhci1waWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2ZyYW1ld29yay90aGVtZS9jb21wb25lbnRzL2NhbGVuZGFyLWtpdC9jb21wb25lbnRzL2NhbGVuZGFyLXllYXItcGlja2VyL2NhbGVuZGFyLXllYXItcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsWUFBWSxFQUNaLFdBQVcsRUFDWCxLQUFLLEVBRUwsTUFBTSxHQUVQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBa0IsY0FBYyxFQUF3QixNQUFNLGFBQWEsQ0FBQztBQUNuRixPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7Ozs7QUFxQjdFLE1BQU0sT0FBTyw2QkFBNkI7SUFVeEMsSUFDSSxjQUFjLENBQUMsYUFBeUM7UUFDMUQsSUFBSSxhQUFhLEVBQUU7WUFDakIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7U0FDcEM7SUFDSCxDQUFDO0lBVUQsSUFDSSxLQUFLO1FBQ1AsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDNUMsQ0FBQztJQUlELFlBQ1ksV0FBNkIsRUFDN0IsZ0JBQStDO1FBRC9DLGdCQUFXLEdBQVgsV0FBVyxDQUFrQjtRQUM3QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQStCO1FBbEIzRCxrQkFBYSxHQUErQiwyQkFBMkIsQ0FBQztRQUUvRCxTQUFJLEdBQW1CLGNBQWMsQ0FBQyxNQUFNLENBQUM7UUFLNUMsZUFBVSxHQUFHLElBQUksWUFBWSxFQUFLLENBQUM7SUFZMUMsQ0FBQztJQUVKLFdBQVc7UUFDVCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRCxRQUFRLENBQUMsSUFBSTtRQUNYLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdCLENBQUM7OzBIQTNDVSw2QkFBNkI7OEdBQTdCLDZCQUE2Qiw0VUFmOUI7Ozs7Ozs7Ozs7OztHQVlUOzJGQUdVLDZCQUE2QjtrQkFqQnpDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLHlCQUF5QjtvQkFDbkMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7R0FZVDtvQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtpQkFDaEQ7NklBR1UsSUFBSTtzQkFBWixLQUFLO2dCQUVHLEdBQUc7c0JBQVgsS0FBSztnQkFFRyxHQUFHO3NCQUFYLEtBQUs7Z0JBRUcsTUFBTTtzQkFBZCxLQUFLO2dCQUdGLGNBQWM7c0JBRGpCLEtBQUs7dUJBQUMsZUFBZTtnQkFRYixJQUFJO3NCQUFaLEtBQUs7Z0JBR0csSUFBSTtzQkFBWixLQUFLO2dCQUVJLFVBQVU7c0JBQW5CLE1BQU07Z0JBR0gsS0FBSztzQkFEUixXQUFXO3VCQUFDLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cblxuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxuICBUeXBlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5iQ2FsZW5kYXJDZWxsLCBOYkNhbGVuZGFyU2l6ZSwgTmJDYWxlbmRhclNpemVWYWx1ZXMgfSBmcm9tICcuLi8uLi9tb2RlbCc7XG5pbXBvcnQgeyBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQgfSBmcm9tICcuL2NhbGVuZGFyLXllYXItY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmJEYXRlU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBOYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NhbGVuZGFyLXllYXItbW9kZWwuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLXllYXItcGlja2VyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmItY2FsZW5kYXItcGlja2VyXG4gICAgICBbZGF0YV09XCJ5ZWFyc1wiXG4gICAgICBbbWluXT1cIm1pblwiXG4gICAgICBbbWF4XT1cIm1heFwiXG4gICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICBbc2VsZWN0ZWRWYWx1ZV09XCJkYXRlXCJcbiAgICAgIFt2aXNpYmxlRGF0ZV09XCJ5ZWFyXCJcbiAgICAgIFtjZWxsQ29tcG9uZW50XT1cImNlbGxDb21wb25lbnRcIlxuICAgICAgW3NpemVdPVwic2l6ZVwiXG4gICAgICAoc2VsZWN0KT1cIm9uU2VsZWN0KCRldmVudClcIj5cbiAgICA8L25iLWNhbGVuZGFyLXBpY2tlcj5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE5iQ2FsZW5kYXJZZWFyUGlja2VyQ29tcG9uZW50PEQ+IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICBASW5wdXQoKSBkYXRlOiBEO1xuXG4gIEBJbnB1dCgpIG1pbjogRDtcblxuICBASW5wdXQoKSBtYXg6IEQ7XG5cbiAgQElucHV0KCkgZmlsdGVyOiAoRCkgPT4gYm9vbGVhbjtcblxuICBASW5wdXQoJ2NlbGxDb21wb25lbnQnKVxuICBzZXQgX2NlbGxDb21wb25lbnQoY2VsbENvbXBvbmVudDogVHlwZTxOYkNhbGVuZGFyQ2VsbDxELCBEPj4pIHtcbiAgICBpZiAoY2VsbENvbXBvbmVudCkge1xuICAgICAgdGhpcy5jZWxsQ29tcG9uZW50ID0gY2VsbENvbXBvbmVudDtcbiAgICB9XG4gIH1cbiAgY2VsbENvbXBvbmVudDogVHlwZTxOYkNhbGVuZGFyQ2VsbDxELCBEPj4gPSBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQ7XG5cbiAgQElucHV0KCkgc2l6ZTogTmJDYWxlbmRhclNpemUgPSBOYkNhbGVuZGFyU2l6ZS5NRURJVU07XG4gIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zaXplOiBOYkNhbGVuZGFyU2l6ZVZhbHVlcztcblxuICBASW5wdXQoKSB5ZWFyOiBEO1xuXG4gIEBPdXRwdXQoKSB5ZWFyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEPigpO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1sYXJnZScpXG4gIGdldCBsYXJnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgfVxuXG4gIHllYXJzOiBEW11bXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD4sXG4gICAgcHJvdGVjdGVkIHllYXJNb2RlbFNlcnZpY2U6IE5iQ2FsZW5kYXJZZWFyTW9kZWxTZXJ2aWNlPEQ+LFxuICApIHt9XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgdGhpcy55ZWFycyA9IHRoaXMueWVhck1vZGVsU2VydmljZS5nZXRWaWV3WWVhcnModGhpcy55ZWFyKTtcbiAgfVxuXG4gIG9uU2VsZWN0KHllYXIpIHtcbiAgICB0aGlzLnllYXJDaGFuZ2UuZW1pdCh5ZWFyKTtcbiAgfVxufVxuIl19